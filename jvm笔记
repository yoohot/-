第一章 简介
java8 hotspot吸收jrockit优点
java=java语言规范+jvm规范，很多jvm规范的其他语言 grovvy，scala。。。

java语言规范：
  语法，变量，类型，文法，内存模型，类加载链接过程，异常。。。
jvm规范： 
  Class文件类型，运行时数据，栈帧，虚拟机启动，虚拟机指令集，堆，栈，方法区，编译，javap，jvm反汇编格式

负数表示方式：补码=反码+1，使用补码的原因，
 1数字0不管是正数表示还是负数表示方式，都是一样的 00000000
 2 运算更方便：直接补码相加即可

jvm 需要对java library提供以下支持：
1反射 java.lang.reflect
2ClassLoader
3初始化class和interface
4安全相关 java.security
5多线程
6弱引用
运行参数 -XX:HeapDumpOnOutOfMemoryError 堆内存溢出时快照，可以使用Eclipse Memory Analyzer分析这个快照文件
jconsole初探
java8对jvm改进只有一点去掉PermGenSpace(持久带)，用Metaspace替代，参数 --XX:MetaSpaceSize和--XX:MaxMetaSpaceSize 替代原来的--XX:PermSize和--XX:MaxPermSize

第二章 jvm虚拟机
ClassicVM： 第一款商用虚拟机，只能纯解释器的方式执行java代码   
ExactVM：
HotSpotVM： java1.3开始
KVM： 简单，轻量，高度可移植，在手机平台运行 
JRockit：Bea公司出，最快的java虚拟机，专注服务器端应用，优点：垃圾收集器，MissionControl服务套件
J9：IBM公司出  
Dalvik：非java虚拟机，Android使用，google
MicrosoftVM：微软公司出
AzulVM & LiquidVM 高性能虚拟机
TaobaoVM： 阿里出

第三章 java内存
运行时数据区:线程共享区：方法区，java堆。线程独占区：虚拟机栈，本地方法栈，程序计数器

1程序计数器：线程独占， 较小内存区域，如果当前线程在执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行的是native方法，这个计数器的值为undefined；此区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域
2虚拟机栈：线程独有，java方法执行的动态内存模型；栈帧：每个方法执行都会创建一个栈帧，一个线程可能会创建很多栈帧，存放到方法栈里（先进后出），伴随着方法的创建到执行完成，用于存放局部变量表，操作数栈，动态链表，方法出口等；局部变量表：存放编译器可知的各种基本数据类型，引用数据类型，returnAddress类型。局部变量表内存空间在编译器完成分配，当进入一个方法时，这个方法需要在帧里分配多少内存是确定的，执行期间大小不会改变；虚拟机栈大小：当进栈的栈帧太多，会导致StackOverFlowError异常；当栈分配大小不足时，报OutOfMemoryError
3本地方法栈：线程独占，类似虚拟机栈（hotspot没有区分这两个；为虚拟机执行native方法服务)，也会抛出StackOverFlowError或OutOfMemoryError
4堆内存：线程共享，最大的内存区域，存储对象的实例（非所有对象都放堆内存），垃圾收集器管理的主要区域；新生代，老年代； 堆内存不够：OutOfMemoryError   -Xmx -Xms 调整堆大小
5方法区：线程共享，存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据；在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区，一个是标准一个是实现。（jrocket，c9等并没有永久代），hotspot在java7中改良了，java8中永久移除永久代，新出现的元空间(Metaspace)来代替原来的永久带；方法区垃圾回收：eg常量池回收，类型卸载等； 内存不够 OutOfMemoryError
ext：https://www.cnblogs.com/paddix/p/5309550.html
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。在JDK1.7中, 已经把原本放在永久代的字符串常量池移出, 放在堆中。jdk8中，静态变量放入堆中。类型元数据移到了元空间(Metaspace)中

运行时常量池： String.intern()生成运行时字符串常量到常量池，new String在堆中生成，常量池非jvm规范的区域

第四章：对象 
对象创建
new 类名->根据class在常量池中查找类的符号引用->如果没有，说明未被加载，执行类的加载，解析，初始化->虚拟机为对象分配内存（堆中）->对象内存初始化为默认值->执行构造方法等init；
为对象分配内存方式：指正碰撞，空闲列表
分配对象线程安全问题：线程同步，本地线程分配缓冲

对象结构：
 Header（对象头MarkWord）：
   自身运行时数据：哈希值 GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳 等。
   类型指针： 
 InstanceData（数据实例）： 
 Padding：占位符，填充对象，对象大小8的整数倍

对象访问定位：
 使用句柄：堆内存中有一块句柄池，指向不同的对象地址，栈中引用指向这些句柄；优点：垃圾回收整理不需要改引用地址
 直接指针：hotspot采用这个，速度快


第六章 垃圾回收
https://www.cnblogs.com/cielosun/p/6674431.html#21-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95mark-sweep
1判断对象是否为垃圾
  引用计数法：基本没有正真使用这个算法的jvm，在堆类可能出现闭环引用导致无法回收
  可达性分析法：从GCRoot（栈）开始查找；可作为GCRoot的对象：虚拟机栈、方法区中类属性所引用的对象、方法区中常量所引用的对象，本地方法栈中引用的对象
  jvm参数：-verbose:gc 打印gc简单信息， 再加上-xx:+PrintGCDetail 打印详细信息
2垃圾回收算法        
  标记-清除算法：效率不高，空间离散
  复制算法：    
  标记-整理算法：  
  分代收集算法：标记整理和复制算法结合;目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域,根据不同区域选择不同的算法。
3垃圾收集器 
  Serial/SerialOld收集器:单线程收集器，与其他线程不能并行执行；Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。
  ParNew收集器：Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集，与其他线程不能并行执行
  Parallel收集器：新生代的并行收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。：java代码时间/（java代码时间+垃圾收集时间）
                 -XX:MaxGCPauseMills:垃圾收集器最大停顿时间  -XX:GCTimeRatio吞吐量大小
  Parallel Old收集器：Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程
  CMS收集器：Current Mark Sweep收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用Mark-Sweep算法。
  G1收集器：收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。
  
第七章 内存分配
分配策略：
 优先分配Eden区：
 大对象直接分配到老年代:因为一般大对象内存比较大，存活比较久，如果放到eden，新生代采用复制算法回收会消耗很多内存；-XX:PretenureSizeThrehold 可指定大对象临界值
 长期存活的对象分配到老年代：-XX:MaxTenuringThreshold 可指定存活年龄（），并不严格按这个参数
 空间分配担保：-XX:+HandlePromotionFailure 是否启用 +启用 -禁用，如果新生代内存不够，将使用老年代内存
 逃逸分析与栈上分配：逃逸分析：分析对象的作用域，当一个对象作用域只限于方法内，即未逃逸，直接在栈上分配
MinorGC:当eden空间不足时发生在新生代的gc，回收速度较快，次数较频繁
MajorGC:也成为FullGC，发生在老年代的gc比minorGC慢的多，因此应用因MajorGC停顿的时间更长


第八章 虚拟机工具
命令行工具：
Jps：用的最多的工具， 查看java进程；
   参数 eg: jps -l 查看main class;-m main函数运行时参数； -v 接收的 vm参数
Jstat：类加载，内存，垃圾收集，jit编译信息等，依赖于jps查看进程号 使用：jstat -参数 pid
   参数：gcutil 查看gc信息 jstat -gcutil pid 1000 10 隔一秒运行一次，总共运行10次
Jinfo:  实时查看和调整虚拟机的各项参数， 依赖于jps查出的pid，使用 jinfo -参数 pid
   参数：不加参数，打印出所有参数情况； -flag name 查看name参数状况（name前+、- 可调整这个参数）
Jmap：主要用来生成heap dump文件， 依赖于jps查出的pid，使用 jmap -参数 pid
   参数：-heap:... 
Jhat：jvm heap分析工具，结合jmap使用，消耗性能，使用很少，使用 jhat -参数 file，会生成一个http server 端口默认7000，可以浏览器查看heap分析结果
Jstack：查看线程快照 使用 jstack -参数 pid
  参数：
图形化工具：
Jconsole：内存，线程等监控；eg：排查线程死锁
VisualVM：最强大的监控工具，非jdk自带，可以安装很多插件

第九章 性能调优

第十章 Class文件结构'
http://blog.csdn.net/a19881029/article/details/16117251
魔数：class文件内容前面规定为CA FE BA BE作为标识
Class文件版本：java版本
常量池：访问标志： 
类引用：
字段表集合：
方法表集合：
属性表集合：

第十一章： 字节码指令

第十二章:类加载机制
类生命周期：装载-> 连接（验证、准备、解析）->初始化->使用->卸载
加载连接中间可并行执行；类初始化的五种情况：
  1遇到new/getstatic/putstatic/invokestatic这四条字节码指令时 
  2 使用java.lang.reflect放射方法调用时 
  3当初始化一个类时，如果发现其父类未初始化，则先触发父类的初始化 
  4当虚拟机启动时，如果需要指定一个要执行的主类（main方法），虚拟机会先初始化这个主类 
  5 1.7新增的
不被初始化的情况： 
  1 通过子类引用父类的静态字段，子类不会被初始化
  2 通过数组定义来引用类eg Example[] es=new Example[10],该类不会被初始化 
  3 调用类的常量 
装载：1通过类全限定名来获取定义此类的二进制流（文件，网络,计算生成如proxy...）2将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构3在内存中生成一个代表这个类的Class对象作为这个类的各种       数据访问的入口（hotspot Class对象放方法区中）
连接：1 验证： 2 准备：为类的变量分配内存并设置"static类变量"初始值，即默认值如int 则为0，这些变量内存都将在方法区中分配   3 解析：虚拟机将常量池中的符号引用替换为直接引用的过程
类加载器:  Bootstrap(javahome/lib)- 扩展类加载器(javahome/lib/ext) - 应用类加载器(用户) - 自定义类加载器；不同类加载器加载的同一字节码文件所生成的Class对象不相等：双亲委派：
JIT编译器：运行时将热点代码交给jit编译器编译为本地代码加快运行速度，编译时间指的就是这个耗时
自动拆箱封箱：就是在编译阶段调用对应的valueOf方法
解释运行：虚拟机运行java指令
编译执行：虚拟机直接运行jit编译本地代码



第十二章 虚拟机字节码执行引擎
1运行时栈帧结构
 局部变量表：局部变量未赋值不能使用，类变量可以，因为类变量在装载和初始化阶段有赋默认值；slot复用??
 操作数栈
 动态链接
 方法返回地址
 附加信息


第十三章 其他
 violate :线程可见性、指令重排序、double|long原子操作；final和synchronize也可以保证可见性
 原子性、可见性和有序性：
 现行发生原则：操作A先于操作B，则操作A的影响能被B观察到，影响包括共享变量的修改。。。
 ①程序次序规则：一个线程内，控制流前面的操作现行于控制流后面的操作
 ②传递性：a先于b,b先于c,则a先于c
 ③管控锁定规则：一个lock先行于同把锁的unlock
 ...

 java1.6对synchronize做了优化，跟lock性能差别不大。1.6之后性能就不是考虑的因素
 锁优化：
  自旋锁：挂起线程和恢复线程都需要转为内核态完成，如果锁定状态很短，那这个挂起和恢复就不值得；所以让这个等待锁的线程自旋，但不放弃处理器执行时间。避免了线程切换的开销，但它仍然占用cpu资源，
          所以如果锁定的时间很短，效果会非常好，相反，则自旋的线程会白白浪费cpu资源
  锁消除：
  锁粗化：
  轻量级锁：
  偏向锁：

