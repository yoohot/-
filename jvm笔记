第一章 简介
java8 hotspot吸收jrockit优点
java=java语言规范+jvm规范，很多jvm规范的其他语言 grovvy，scala。。。

java语言规范：
  语法，变量，类型，文法，内存模型，类加载链接过程，异常。。。
jvm规范： 
  Class文件类型，运行时数据，栈帧，虚拟机启动，虚拟机指令集，堆，栈，方法区，编译，javap，jvm反汇编格式

负数表示方式：补码=反码+1，使用补码的原因，
 1数字0不管是正数表示还是负数表示方式，都是一样的 00000000
 2 运算更方便：直接补码相加即可

jvm 需要对java library提供以下支持：
1反射 java.lang.reflect
2ClassLoader
3初始化class和interface
4安全相关 java.security
5多线程
6弱引用
运行参数 -XX:HeapDumpOnOutOfMemoryError 堆内存溢出时快照，可以使用Eclipse Memory Analyzer分析这个快照文件
jconsole初探
java8对jvm改进只有一点去掉PermGenSpace(持久带)，用Metaspace替代，参数 --XX:MetaSpaceSize和--XX:MaxMetaSpaceSize 替代原来的--XX:PermSize和--XX:MaxPermSize

第二章 jvm虚拟机
ClassicVM： 第一款商用虚拟机，只能纯解释器的方式执行java代码   
ExactVM：
HotSpotVM： java1.3开始
KVM： 简单，轻量，高度可移植，在手机平台运行 
JRockit：Bea公司出，最快的java虚拟机，专注服务器端应用，优点：垃圾收集器，MissionControl服务套件
J9：IBM公司出  
Dalvik：非java虚拟机，Android使用，google
MicrosoftVM：微软公司出
AzulVM & LiquidVM 高性能虚拟机
TaobaoVM： 阿里出

第三章 java内存
运行时数据区:线程共享区：方法区，java堆。线程独占区：虚拟机栈，本地方法栈，程序计数器

1程序计数器：线程独占， 较小内存区域，如果当前线程在执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行的是native方法，这个计数器的值为undefined；此区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域
2虚拟机栈：线程独有，java方法执行的动态内存模型；栈帧：每个方法执行都会创建一个栈帧，一个线程可能会创建很多栈帧，存放到方法栈里（先进后出），伴随着方法的创建到执行完成，用于存放局部变量表，操作数栈，动态链表，方法出口等；局部变量表：存放编译器可知的各种基本数据类型，引用数据类型，returnAddress类型。局部变量表内存空间在编译器完成分配，当进入一个方法时，这个方法需要在帧里分配多少内存是确定的，执行期间大小不会改变；虚拟机栈大小：当进栈的栈帧太多，会导致StackOverFlowError异常
3本地方法栈：线程独占，类似虚拟机栈（hotspot没有区分这两个；为虚拟机执行native方法服务)
4堆内存：线程共享，最大的内存区域，存储对象的实例（非所有对象都放堆内存），垃圾收集器管理的主要区域；新生代，老年代； 堆内存不够：OutOfMemoryError   -Xmx -Xms 调整堆大小
5方法区：线程共享，存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据；在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区，一个是标准一个是实现。（jrocket，c9等并没有永久代），hotspot在java7中改良了，java8中永久移除永久代，新出现的元空间(Metaspace)来代替原来的永久带；方法区垃圾回收：eg常量池回收，类型卸载等； 内存不够 OutOfMemoryError
ext：https://www.cnblogs.com/paddix/p/5309550.html
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。在JDK1.7中, 已经把原本放在永久代的字符串常量池移出, 放在堆中。jdk8中，静态变量放入堆中。类型元数据移到了元空间(Metaspace)中

运行时常量池： String.intern()生成运行时字符串常量到常量池，new String在堆中生成，常量池非jvm规范的区域

第四章：对象 
对象创建
new 类名->根据class在常量池中查找类的符号引用->如果没有，说明未被加载，执行类的加载，解析，初始化->虚拟机为对象分配内存（堆中）->对象内存初始化为默认值->执行构造方法等init；
为对象分配内存方式：指正碰撞，空闲列表
分配对象线程安全问题：线程同步，本地线程分配缓冲

对象结构：
 Header（对象头MarkWord）：
   自身运行时数据：哈希值 GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳 等。
   类型指针： 
 InstanceData（数据实例）： 
 Padding：占位符，填充对象，对象大小8的整数倍

对象访问定位：
 使用句柄：堆内存中有一块句柄池，指向不同的对象地址，栈中引用指向这些句柄；优点：垃圾回收整理不需要改引用地址
 直接指针：hotspot采用这个，速度快

第六章 垃圾回收
https://www.cnblogs.com/cielosun/p/6674431.html#21-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95mark-sweep
1判断对象是否为垃圾
  引用计数法：基本没有正真使用这个算法的jvm，在堆类可能出现闭环引用导致无法回收
  可达性分析法：从GCRoot（栈）开始查找；可作为GCRoot的对象：虚拟机栈、方法区中类属性所引用的对象、方法区中常量所引用的对象，本地方法栈中引用的对象
  jvm参数：-verbose:gc 打印gc简单信息， 再加上-xx:+PrintGCDetail 打印详细信息
2垃圾回收算法        
  标记-清除算法：效率不高，空间离散
  复制算法：    
  标记-整理算法： 
  分代收集算法：标记整理和复制算法结合;目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域,根据不同区域选择不同的算法。
3垃圾收集器 
  Serial/SerialOld收集器:单线程收集器，与其他线程不能并行执行；Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。
  ParNew收集器：Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集，与其他线程不能并行执行
  Parallel收集器：新生代的并行收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。：java代码时间/（java代码时间+垃圾收集时间）
                 -XX:MaxGCPauseMills:垃圾收集器最大停顿时间  -XX:GCTimeRatio吞吐量大小
  Parallel Old收集器：Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程
  CMS收集器：Current Mark Sweep收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用Mark-Sweep算法。
  G1收集器：收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。
  
第七章 内存分配
分配策略：
 优先分配Eden区：
 大对象直接分配到老年代:因为一般大对象内存比较大，存活比较久，如果放到eden，新生代采用复制算法回收会消耗很多内存；-XX:PretenureSizeThrehold 可指定大对象临界值
 长期存活的对象分配到老年代：-XX:MaxTenuringThreshold 可指定存活年龄（），并不严格按这个参数
 空间分配担保：-XX:+HandlePromotionFailure 是否启用 +启用 -禁用，如果新生代内存不够，将使用老年代内存
 逃逸分析与栈上分配：逃逸分析：分析对象的作用域，当一个对象作用域只限于方法内，即未逃逸，直接在栈上分配
MinGC:
MajorGC:
FullGC:

第八章 虚拟机工具
命令行工具：
Jps：用的最多的工具， 查看java进程；
   参数 eg: jps -l 查看main class;-m main函数运行时参数； -v 接收的 vm参数
Jstat：类加载，内存，垃圾收集，jit编译信息等，依赖于jps查看进程号 使用：jstat -参数 pid
   参数：gcutil 查看gc信息 jstat -gcutil pid 1000 10 隔一秒运行一次，总共运行10次
Jinfo:  实时查看和调整虚拟机的各项参数， 依赖于jps查出的pid，使用 jinfo -参数 pid
   参数：不加参数，打印出所有参数情况； -flag name 查看name参数状况（name前+、- 可调整这个参数）
Jmap：主要用来生成heap dump文件， 依赖于jps查出的pid，使用 jmap -参数 pid
   参数：-heap:... 
Jhat：jvm heap分析工具，结合jmap使用，消耗性能，使用很少，使用 jhat -参数 file，会生成一个http server 端口默认7000，可以浏览器查看heap分析结果
Jstack：查看线程快照 使用 jstack -参数 pid
  参数：
图形化工具：
Jconsole：内存，线程等监控；eg：排查线程死锁
VisualVM：最强大的监控工具，非jdk自带，可以安装很多插件

第九章 性能调优

第十章 Class文件结构'
http://blog.csdn.net/a19881029/article/details/16117251
魔数：class文件内容前面规定为CA FE BA BE作为标识
Class文件版本：java版本
常量池：访问标志： 
类引用：
字段表集合：
方法表集合：
属性表集合：