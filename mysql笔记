 InnoDB

第一章 表
 表的所有数据都被逻辑存放在一个空间中，成为表空间，表空间又分为段、区、页（也称为块）；
  段：innodb是索引组织表的，数据即为索引，索引即数据；数据段即为b+树的叶子节点，索引段即为非叶子节点
  区：区是由连续页组成的空间，任何时候区的大小都为1MB，innodb 页大小默认16k，所以默认一个区有64页
  页：磁盘管理的最小单位，页又分为很多种类
 
 分区表：
  讲一个表或索引分解为多个更小、更易管理的部分，就数据库而言，只有一个表或索引；mysql支持水平分区，不支持垂直分区，






第二章 索引与算法
innoDb支持以下索引：
   B+树索引：最常用且最为有效的索引，B+树数据结构在数据库中的实现，树的高度一般在2-4层；又分为聚集索引和辅助索引，不同之处在于是否存一整行数据
            聚集索引：按照每张表的主键构造的一颗B+树，存放整张表的记录，由于实际的数据页只能按照一颗b+树进行顺序，因此每张表只能有一个聚集索引
            辅助索引：叶子节点不包含全部数据，每个叶子节点包含一个bookmark，改书签用来指示哪里可以找到行数据
   全文索引
   哈希索引：自适应的，innodb会根据表的使用情况自动为表生成哈希索引，不能认为干预是否在一张表中生成哈希索引

相关算法和数据结构：
二分查找法： 有序记录中折半查找
二叉查找树：除叶子节点外每个节点有两个子节点
平衡二叉树：任何节点的两个叶子树高度最大差为1，缺点：维护代价高，需要左旋或右旋来得到插入或更新后的树的平衡性。
B+树：平衡查找树，所有记录节点都是按照键的大小顺序放在同一层的最终叶子节点上（LeafPage层，其他的为IndexPage层）， 叶子节点指针进行连接（双向链表）。树高度可变，但是不管如何插入，树都是平衡的
      因为B+树主要用于磁盘，页的拆分意味着磁盘的操作，所以应该尽量减少页的拆分操作。因此，B+树也提供了类似平衡二叉树的旋转操作,旋转发生在LeafPage已满，而左右的兄弟Leaf Page未满的情况下；
      删除操作会导致Page合并操作，所以尽量减少合并删除操作；b不代表二叉，而是代表平衡balance，B+树从平衡二叉树演变过来的，但是B+树不是二叉树，B+树索引并不能找到给定键值的具体行，只是查找到键值所在的页，把该页的数据读到内存然后查找该数据
Hash算法：

Show index from table_name； 
   cardinality:该列唯一值的大概数量，优化器会根据这个值来判断是否使用这个索引
   sub_part:是否列的部分数据，否为NULL    
   null:索引的列是否含NULL值
   index_type:Btree 即b+

mysql5.5之前：索引的添加删除等操作：
   先建立临时表，然后倒入数据到临时表，然后删除原始表等；
5.5开始：FIC（fast index creation） ，加上S锁，可读不可写。只适合辅助索引，重建主键索引仍然会重建表
5.6 Online DDl:增删改查，辅助索引创建删除等

b+树索引使用：
  1联合索引 （a,b）当查询where b='xx'时不走索引，原因是b在b+树索引中叶子节点时非顺序的 例如（1，2）（1，3） （2，1）。。。 ab是顺序的，a是顺序的，b是非顺序的,但是count统计的时候会使用这个索引，explain extra：using index 覆盖索引
  2当查询的结果集大于20%（可调整）时，不走建立的辅助索引，而是走聚集索引



第三章 锁
MyIsam 表级锁 InnoDb 行级锁
在MySQL中，行级锁并不是直接锁记录，而是锁索引；索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引;如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。对于一般的Select语句，InnoDB不会加任何锁
InnoDb行级锁：
  共享锁：可多个事务读r行数据
  排他锁：必须等r上的共享锁释放才可获取排他锁，且另外的事务不能获取
InnoDb表级锁（意向锁）：
  意向共享锁：事务想获取表上某几行的共享锁，与意向共享锁，共享锁兼容
  意向排他锁：事务想获取表上某几行的排他锁，与其他锁不兼容

一致性非锁定读：在read commited，repeatable read隔离级别下，读取undo数据（回滚时用。历史版本数据），不需要等待排他锁释放；read commited总是读最新版本，而repeatable read总是读当前事务开始时版本
一致性锁定读：select ... for update 加排他锁;  select ... lock in share mode 加共享锁；且必须在事务中，事务提交锁释放； 一直性非锁定读仍然可以读（读redo数据）；

行锁算法：https://www.cnblogs.com/aipiaoborensheng/p/5767459.html
  record lock：单个行上锁
  gap lock：间隙锁，锁定一个范围，但是不包含记录本身
  next-key lock：锁定范围且包含记录本身  ，设计目的是为了解决幻读问题
Next-Key Lock是行锁与间隙锁的组合，这样，当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。如果一个间隙被事务T1加了锁，其它事务是不能在这个间隙插入记录的。避免幻读

在默认隔离级别下：对于一般的select...，因为读的是undo 快照数据，不会加锁也不会出现幻读，即使另外的事务insert数据，因为当前sql查询的是undo数据，并不会得到新插入的数据；而对于select ...for update/lock in share mode 等加锁操作，因为是锁索引，若是非聚集索引，则为了避免幻读会锁定范围索引导致出现间隙锁；innodb repeatable read级别避免了幻读，并非严格准找了sql隔离标准

死锁解决方案
  超时：
  wait-for graph 死锁检测：
 

第四章 事物
ACID

事务分类： innodb支持以下除了嵌套事务外的所有事务
 扁平事务
 带保存点的扁平事务
 链事务
 嵌套事务
 分布式事务：两段式提交 第一阶段：所有节点准备就绪 第二阶段：集中管理器告诉commit或rollback，innodb支持XA事务时隔离级别必须是serializable
事务的实现：隔离性：锁  ；持久性 ：redo log  & undo log（回滚使用）
 事务commit： redo日志强制刷新到磁盘redo log文件成功才算成功，会将redo log刷到磁盘缓冲，然后调用fsync强制磁盘缓冲到磁盘文件，可以配置fsync策略，默认每次提交都fsync.

binlog 和redo log: binlog 用来point-in-time的恢复和主从复制的，binlog是mysql数据库层面，redo是存储引擎层面；内容也不同。

SHOW GLOBAL STATUS LIKE 'com_commit' 查看tps

